plot(Google)
attach(stocks)
plot(Google)
acf(diff(log(Google)))
names(persistence)
par(mfrow=c(2,1))
plot(SALINF)
plot(PRINF)
acf(ADVINF)
summary(lmfit(ADVINF~back(ADVINF)+back(ADVINF,n=3)+back(ADVINF,n=6)+back(ADVINF,n=12)))
summary(lm(ADVINF~back(ADVINF)+back(ADVINF,n=3)+back(ADVINF,n=6)+back(ADVINF,n=12)))
lmfit=lm(ADVINF~back(ADVINF)+back(ADVINF,n=3)+back(ADVINF,n=6)+back(ADVINF,n=12)))
lmfit=lm(ADVINF~back(ADVINF)+back(ADVINF,n=3)+back(ADVINF,n=6)+back(ADVINF,n=12))
acf(lmfit$res)
lmfit=lm(ADVINF~back(ADVINF)+back(ADVINF,n=3)+back(ADVINF,n=6)+back(ADVINF,n=12)+back(SALINF))
summary(lmfit)
lmfit=lm(ADVINF~back(ADVINF)+back(ADVINF,n=3)+back(ADVINF,n=6)+back(ADVINF,n=12)+back(SALINF)+back(SALINF,n=3))
summary(lmfit)
sumarry
summary
y=rnorm(20)
x=rnorm(20)
o=lm(y~x)
o
str(o)
o$terms
attributes(0)
rmnpGibbs
attributes(o)
os=summary(o)
names(o)
o$call
o$xlevels
o$model
o$qr
??sandwich
?qr
y=rnorm(10)
X=matrix(rnorm(20,),ncol=2)
?solve
?rmultireg
rmultireg
XtX=crossprod(X)#
rooti=chol2inv(chol(XtX))#
bhat=crossprod(t(rooti))%*%crossprod(X,y)#
H=X%*%crossprod(t(rooti))%*%t(X)
bhat
H
dim(H)
qr.coef(qr(X),y)
lm(y~X)
lm(y~X-1)
?chol2inv
XtX=crossprod(X)#
root=chol(XtX)#
rooti=backsolve(root,diag(ncolX))#
bhat=crossprod(t(rooti))%*%crossprod(X,y)#
H=X%*%crossprod(t(rooti))%*%t(X)
bhat
XtX=crossprod(X)#
root=chol(XtX)#
rooti=backsolve(root,diag(ncol(X)))#
bhat=crossprod(t(rooti))%*%crossprod(X,y)#
H=X%*%crossprod(t(rooti))%*%t(X)
bhat
XtX=crossprod(X)#
root=chol(XtX)#
rooti=backsolve(root,diag(ncol(X)))#
bhat=crossprod(t(rooti))%*%crossprod(X,y)#
H1=X%*%crossprod(t(rooti))%*%t(X)#
H2=crossprod(t(qr.Q(qr(X))))
H1
H2
H!-H@
max(H1-H2)
lmfit=lm(y~X-1)
names(lmfit)
lmfit$coef
qr.coef(lmfit$qr,y)
lmfit$res
qr.resid(lmfit$qr,y)
?qr
M=matrix(c(1:6),ncol=2)
M
M*c(2,2,2)
as.vector(c(2,2,2))%*%M
diag(c(2,2,2))%*%M
?qr.coef
X
qro=qr(X)
qr.R(qro)
backsolve(qr.R(qro),diag(2))
1-c(2,2)
diag(H2)
diag(crossprod(t(qr.Q(qro))))
?rowSums
rowsums(qr.Q(qro)*qr.Q(qro))
rowSums(qr.Q(qro)*qr.Q(qro))
summary(lmfit)
names(lmfit)
lmfit$rank
names(qr(X))
lmfit$coef
X1=x[,1]
X1=X[,1]
X2=x[,2]
lmfit=lm(y~back(X1)+X2)
back
y
X2
X2=X[,2]
lmfit=lm(y~back(X1)+X2)
lmfit$co
names(lmfit$co)
corr(y,back(y))
corr(data.frame(cbind(y,back(y))))
corr(cbind(y,back(y)))
X
k=ncol(X)#
n=nrow(X)#
qrX=qr(X)#
omega=qr.resid(qrX,y)**2#
omega=omega/(1-rowSums(qr.Q(qrX)*qr.Q(qrX)))**2#
#
RIQ=backsolve(qr.R(qrX),diag(k)))%*%qr.Q(qrX)#
VH=crossprod(t(RIQ),t(RIQ)*omega)
k=ncol(X)#
n=nrow(X)#
qrX=qr(X)#
omega=qr.resid(qrX,y)**2#
omega=omega/(1-rowSums(qr.Q(qrX)*qr.Q(qrX)))**2#
#
RIQ=backsolve(qr.R(qrX),diag(k))%*%qr.Q(qrX)#
VH=crossprod(t(RIQ),t(RIQ)*omega)
k
qr.R(qrX)
qr.Q(qrX)
k=ncol(X)#
n=nrow(X)#
qrX=qr(X)#
omega=qr.resid(qrX,y)**2#
omega=omega/(1-rowSums(qr.Q(qrX)*qr.Q(qrX)))**2#
#
RIQt=backsolve(qr.R(qrX),diag(k))%*%t(qr.Q(qrX))#
VH=crossprod(t(RIQt),t(RIQt)*omega)
Vh
VH
H1
 v
e=(diag(n)-H1)%*%y#
omega=e**2#
omega=omega/(1-diag(H1))**2#
C=X%*%rooti%*%t(rooti)#
crossprod(t(C),c*omega)
omega
C
e=(diag(n)-H1)%*%y#
omega=e**2#
omega=omega/(1-diag(H1))**2#
C=X%*%rooti%*%t(rooti)#
crossprod(t(C),C*omega)
dim(C)
omega
C
C*omega
str(omega)
C*as.vector(omega)
e=(diag(n)-H1)%*%y#
omega=e**2#
omega=omega/(1-diag(H1))**2#
C=X%*%rooti%*%t(rooti)#
crossprod(t(C),C*as.vector(omega))
C
C*as.vector(omega)
k=ncol(X)#
n=nrow(X)#
qrX=qr(X)#
omega=qr.resid(qrX,y)**2#
omega=omega/(1-rowSums(qr.Q(qrX)*qr.Q(qrX)))**2#
#
QRIt=qr.Q(qrX)%*%t(backsolve(qr.R(qrX),diag(k)))#
VH=crossprod(QRIt,QRIt*omega)
VH
e=(diag(n)-H1)%*%y#
omega=e**2#
omega=omega/(1-diag(H1))**2#
C=X%*%rooti%*%t(rooti)#
crossprod(C,C*as.vector(omega))
lmfit
attributes(lmfit)
lmfit$qr
sqrt(diag(VH))
summary(lm(y~X))
summary(lm(y~X-1))
ncol(lmfit$qr)
$qr
ncol(lmfit$qr$qr)
HeteroVar=function(qrX,res){#
	# 2/11 P. Rossi#
	#  function to compute H3 -- heteroskedastic consistent Var-Cov matrix using QR decomposition of X, and residuals#
	##
	#  (X'X)-1X'OmegaH X(X'X)-1#
	# OmegaH = diag(e_i^2/(1-hii)^2)    -- hii is i,i, element of hat matrix#
	##
	#  in terms of X=QR  this is R-1Q' OmegaH Q(R-1)'#
	# note the hat matrix is QQ'#
	##
	# code below does this with cholesky roots and was used for checking#
	#    XtX=crossprod(X)#
	#    root=chol(XtX)#
	#    rooti=backsolve(root,diag(ncol(X)))#
	#    bhat=crossprod(t(rooti))%*%crossprod(X,y)#
	#    H1=X%*%crossprod(t(rooti))%*%t(X)#
	#    H2=crossprod(t(qr.Q(qr(X))))#
	#    e=(diag(n)-H1)%*%y#
	#    omega=e**2#
	#    omega=omega/(1-diag(H1))**2#
	#    C=X%*%rooti%*%t(rooti)#
	#    crossprod(C,C*as.vector(omega))#
	##
	##
	k=ncol(qr$qr)#
	omega=res**2#
	omega=omega/(1-rowSums(qr.Q(qrX)*qr.Q(qrX)))**2  # here we are fetching diag elements of QQ'#
	QRIt=qr.Q(qrX)%*%t(backsolve(qr.R(qrX),diag(k)))#
	V=crossprod(QRIt,QRIt*omega)#
	std_err=sqrt(diag(V))#
	return(list(V=V,std_err=std_err))#
	#
}
lmfit
y
lmfit=lm(y~X)
HeteroVar(lmfit$qr,lmfit$res)
lmfit$qr
qr.Q(lmfit$qr)
lmfit=lm(y~X-1)
lmfit$qr$qr
debug(HeteroVar)
HeteroVar(lmfit$qr,lmfit$res)
qr
qrX
Q
HeteroVar=function(qrX,res){#
	# 2/11 P. Rossi#
	#  function to compute H3 -- heteroskedastic consistent Var-Cov matrix using QR decomposition of X, and residuals#
	##
	#  (X'X)-1X'OmegaH X(X'X)-1#
	# OmegaH = diag(e_i^2/(1-hii)^2)    -- hii is i,i, element of hat matrix#
	##
	#  in terms of X=QR  this is R-1Q' OmegaH Q(R-1)'#
	# note the hat matrix is QQ'#
	##
	# code below does this with cholesky roots and was used for checking#
	#    XtX=crossprod(X)#
	#    root=chol(XtX)#
	#    rooti=backsolve(root,diag(ncol(X)))#
	#    bhat=crossprod(t(rooti))%*%crossprod(X,y)#
	#    H1=X%*%crossprod(t(rooti))%*%t(X)#
	#    H2=crossprod(t(qr.Q(qr(X))))#
	#    e=(diag(n)-H1)%*%y#
	#    omega=e**2#
	#    omega=omega/(1-diag(H1))**2#
	#    C=X%*%rooti%*%t(rooti)#
	#    crossprod(C,C*as.vector(omega))#
	##
	##
	k=ncol(qrX$qr)#
	omega=res**2#
	omega=omega/(1-rowSums(qr.Q(qrX)*qr.Q(qrX)))**2  # here we are fetching diag elements of QQ'#
	QRIt=qr.Q(qrX)%*%t(backsolve(qr.R(qrX),diag(k)))#
	V=crossprod(QRIt,QRIt*omega)#
	std_err=sqrt(diag(V))#
	return(list(V=V,std_err=std_err))#
	#
}
HeteroVar(lmfit$qr,lmfit$res)
library(sandwich)
library(sandwich)
vcovHC(lmfit,omega=NULL,type="HC3")
attributes(lmfit)$class
summary(lmfit)
sm=summary(lmfit)
sm
names(sm)
sm$signam
sm$sigma
sm$fstat
names(lmfit)
lmfit$call
HeteroVar=function(qrX,res,hcon=FALSE){#
	# 2/11 P. Rossi#
	#  function to compute H3 -- heteroskedastic consistent Var-Cov matrix using QR decomposition of X, and residuals#
	##
	#  (X'X)-1X'OmegaH X(X'X)-1#
	# OmegaH = diag(e_i^2/(1-hii)^2)    -- hii is i,i, element of hat matrix#
	##
	#  in terms of X=QR  this is R-1Q' OmegaH Q(R-1)'#
	# note the hat matrix is QQ'#
	##
	# code below does this with cholesky roots and was used for checking#
	#    XtX=crossprod(X)#
	#    root=chol(XtX)#
	#    rooti=backsolve(root,diag(ncol(X)))#
	#    bhat=crossprod(t(rooti))%*%crossprod(X,y)#
	#    H1=X%*%crossprod(t(rooti))%*%t(X)#
	#    H2=crossprod(t(qr.Q(qr(X))))#
	#    e=(diag(n)-H1)%*%y#
	#    omega=e**2#
	#    omega=omega/(1-diag(H1))**2#
	#    C=X%*%rooti%*%t(rooti)#
	#    crossprod(C,C*as.vector(omega))#
	##
	##
	k=ncol(qrX$qr)#
	RI=backsolve(qr.R(qrX),diag(k))#
	if(hcon) #
	{#
	  omega=res**2#
	  omega=omega/(1-rowSums(qr.Q(qrX)*qr.Q(qrX)))**2  # here we are fetching diag elements of QQ'#
	  QRIt=qr.Q(qrX)%*%t(RI)#
	  V=crossprod(QRIt,QRIt*omega) #
	}#
	else#
	{#
	   s=sqrt(sum(res**2)/(length(res)-k))#
	   V=s**2*crossprod(t(RI))#
	}#
	std_err=sqrt(diag(V))#
	return(list(V=V,std_err=std_err))#
}
HeteroVar(lmfit$qr,lmfit$res,hcon=TRUE)
HeteroVar(lmfit$qr,lmfit$res,hcon=FALSE)
summary(lmfit)
names(slm)
ls()
sm
names(ms)
names(sm)
sm$coef
lmfit$coef
?rownames
lmfit(coef)
lmfit$coef
names(lmfit$coef)
?round
?round
lmfit$call
log(100)
log(1000)
HACVar=function(qrX,res,L){#
	# 2/11 P. Rossi#
	#  function  to compute heteroskedastic autocorrelation#
	#   consistent Var-Cov matrix using QR decomposition of X, and residuals#
	##
	#  (X'X)-1 Omegahat (X'X)-1#
	# if L=0, Phi0 = X' diag(e_i^2/(1-hii)^2) X  -- hii is i,i, element of hat matrix use "H3" method from sandwich#
	# if Lne0, Omegahat = omega_0*Phi_0 + 2sum(l=1 to L) omega_l*Phi_l ; omega_l = 1 - (l/L+1)#
	#        phi_l=sum(t=l+1 to T) x_t e_t e_t-l (x_t-l)'  x_t is the "t"th row of X and e_t is the lsq residual#
	# or#
	#        phi_l= (XP*ep)'(XM*em)#
	#        XP=X[l:T,] ep[l:T] ; XM=X[1:(T-l),]  em[1:T-l]#
	##
	#  in terms of X=QR  this is R-1(R-1)' OmegaH R-1(R-1)'#
	# note the hat matrix is QQ'#
	##
	##
	k=ncol(qrX$qr)#
	R=qr.R(qrX)#
	Q=qr.Q(qrX)#
	X=Q%*%R#
	n=nrow(X)#
	RI=backsolve(R,diag(k))#
	if(L=0)#
	  lambda=res**2#
	  lambda=lambda/((1-rowSums(Q*Q)**2)    # here we are fetching diag elements of QQ'#
	  QRIt=Q%*%t(RI)#
	  V=crossprod(QRIt,QRIt*lambda)       # for L=0, V=(X'X)-1X' Lambda X (X'X)-1 = t(QRI) Lambda QRI#
	}#
	else#
	{#
		phi0=crossprod(X,X*lambda)#
		Omegahat=phi0#
		for(l in 1:L )#
		{#
			omega_l=1-l/(L+1)	 		# N-W weights#
			Omegahat=Omegahat+2*omega_l*crossprod((X[l:n,]*res[l:n]),(X[1:(n-l),]*res[1:(n-l)]))#
		}#
	   XpXI=crossprod(t(RI))#
	   V=crossprod(XpXI,Omegahat%*%XpXI)#
	}#
	std_err=sqrt(diag(V))#
	return(list(V=V,std_err=std_err))#
}
HACVar=function(qrX,res,L){#
	# 2/11 P. Rossi#
	#  function  to compute heteroskedastic autocorrelation#
	#   consistent Var-Cov matrix using QR decomposition of X, and residuals#
	##
	#  (X'X)-1 Omegahat (X'X)-1#
	# if L=0, Phi0 = X' diag(e_i^2/(1-hii)^2) X  -- hii is i,i, element of hat matrix use "H3" method from sandwich#
	# if Lne0, Omegahat = omega_0*Phi_0 + 2sum(l=1 to L) omega_l*Phi_l ; omega_l = 1 - (l/L+1)#
	#        phi_l=sum(t=l+1 to T) x_t e_t e_t-l (x_t-l)'  x_t is the "t"th row of X and e_t is the lsq residual#
	# or#
	#        phi_l= (XP*ep)'(XM*em)#
	#        XP=X[l:T,] ep[l:T] ; XM=X[1:(T-l),]  em[1:T-l]#
	##
	#  in terms of X=QR  this is R-1(R-1)' OmegaH R-1(R-1)'#
	# note the hat matrix is QQ'#
	##
	##
	k=ncol(qrX$qr)#
	R=qr.R(qrX)#
	Q=qr.Q(qrX)#
	X=Q%*%R#
	n=nrow(X)#
	RI=backsolve(R,diag(k))#
	if(L==0)#
	  lambda=res**2#
	  lambda=lambda/((1-rowSums(Q*Q)**2)    # here we are fetching diag elements of QQ'#
	  QRIt=Q%*%t(RI)#
	  V=crossprod(QRIt,QRIt*lambda)       # for L=0, V=(X'X)-1X' Lambda X (X'X)-1 = t(QRI) Lambda QRI#
	}#
	else#
	{#
		phi0=crossprod(X,X*lambda)#
		Omegahat=phi0#
		for(l in 1:L )#
		{#
			omega_l=1-l/(L+1)	 		# N-W weights#
			Omegahat=Omegahat+2*omega_l*crossprod((X[l:n,]*res[l:n]),(X[1:(n-l),]*res[1:(n-l)]))#
		}#
	   XpXI=crossprod(t(RI))#
	   V=crossprod(XpXI,Omegahat%*%XpXI)#
	}#
	std_err=sqrt(diag(V))#
	return(list(V=V,std_err=std_err))#
}
HACVar=function(qrX,res,L){#
	# 2/11 P. Rossi#
	#  function  to compute heteroskedastic autocorrelation#
	#   consistent Var-Cov matrix using QR decomposition of X, and residuals#
	##
	#  (X'X)-1 Omegahat (X'X)-1#
	# if L=0, Phi0 = X' diag(e_i^2/(1-hii)^2) X  -- hii is i,i, element of hat matrix use "H3" method from sandwich#
	# if Lne0, Omegahat = omega_0*Phi_0 + 2sum(l=1 to L) omega_l*Phi_l ; omega_l = 1 - (l/L+1)#
	#        phi_l=sum(t=l+1 to T) x_t e_t e_t-l (x_t-l)'  x_t is the "t"th row of X and e_t is the lsq residual#
	# or#
	#        phi_l= (XP*ep)'(XM*em)#
	#        XP=X[l:T,] ep[l:T] ; XM=X[1:(T-l),]  em[1:T-l]#
	##
	#  in terms of X=QR  this is R-1(R-1)' OmegaH R-1(R-1)'#
	# note the hat matrix is QQ'#
	##
	##
	k=ncol(qrX$qr)#
	R=qr.R(qrX)#
	Q=qr.Q(qrX)#
	X=Q%*%R#
	n=nrow(X)#
	RI=backsolve(R,diag(k))#
	if(L==0)#
	  lambda=res**2#
	  lambda=lambda/((1-rowSums(Q*Q))**2)    # here we are fetching diag elements of QQ'#
	  QRIt=Q%*%t(RI)#
	  V=crossprod(QRIt,QRIt*lambda)       # for L=0, V=(X'X)-1X' Lambda X (X'X)-1 = t(QRI) Lambda QRI#
	}#
	else#
	{#
		phi0=crossprod(X,X*lambda)#
		Omegahat=phi0#
		for(l in 1:L )#
		{#
			omega_l=1-l/(L+1)	 		# N-W weights#
			Omegahat=Omegahat+2*omega_l*crossprod((X[l:n,]*res[l:n]),(X[1:(n-l),]*res[1:(n-l)]))#
		}#
	   XpXI=crossprod(t(RI))#
	   V=crossprod(XpXI,Omegahat%*%XpXI)#
	}#
	std_err=sqrt(diag(V))#
	return(list(V=V,std_err=std_err))#
}
HACVar=function(qrX,res,L){#
	# 2/11 P. Rossi#
	#  function  to compute heteroskedastic autocorrelation#
	#   consistent Var-Cov matrix using QR decomposition of X, and residuals#
	##
	#  (X'X)-1 Omegahat (X'X)-1#
	# if L=0, Phi0 = X' diag(e_i^2/(1-hii)^2) X  -- hii is i,i, element of hat matrix use "H3" method from sandwich#
	# if Lne0, Omegahat = omega_0*Phi_0 + 2sum(l=1 to L) omega_l*Phi_l ; omega_l = 1 - (l/L+1)#
	#        phi_l=sum(t=l+1 to T) x_t e_t e_t-l (x_t-l)'  x_t is the "t"th row of X and e_t is the lsq residual#
	# or#
	#        phi_l= (XP*ep)'(XM*em)#
	#        XP=X[l:T,] ep[l:T] ; XM=X[1:(T-l),]  em[1:T-l]#
	##
	#  in terms of X=QR  this is R-1(R-1)' OmegaH R-1(R-1)'#
	# note the hat matrix is QQ'#
	##
	##
	k=ncol(qrX$qr)#
	R=qr.R(qrX)#
	Q=qr.Q(qrX)#
	X=Q%*%R#
	n=nrow(X)#
	RI=backsolve(R,diag(k))#
	if(L==0)#
	{#
	  lambda=res**2#
	  lambda=lambda/((1-rowSums(Q*Q))**2)    # here we are fetching diag elements of QQ'#
	  QRIt=Q%*%t(RI)#
	  V=crossprod(QRIt,QRIt*lambda)       # for L=0, V=(X'X)-1X' Lambda X (X'X)-1 = t(QRI) Lambda QRI#
	}#
	else#
	{#
		phi0=crossprod(X,X*lambda)#
		Omegahat=phi0#
		for(l in 1:L )#
		{#
			omega_l=1-l/(L+1)	 		# N-W weights#
			Omegahat=Omegahat+2*omega_l*crossprod((X[l:n,]*res[l:n]),(X[1:(n-l),]*res[1:(n-l)]))#
		}#
	   XpXI=crossprod(t(RI))#
	   V=crossprod(XpXI,Omegahat%*%XpXI)#
	}#
	std_err=sqrt(diag(V))#
	return(list(V=V,std_err=std_err))#
}
y
X
lmfit
summary(lmfit)
vcovHC(lmfit,type="HC3")
ls()
HACVar(lmfit$qr,lmfit$res,L=0,HAC=TRUE)
HACVAR(lmfit$qr,lmfit$res,L=0)
HACVar(lmfit$qr,lmfit$res,L=0)
HACVar(lmfit$qr,lmfit$res,L=1)
HACVar=function(qrX,res,L){#
	# 2/11 P. Rossi#
	#  function  to compute heteroskedastic autocorrelation#
	#   consistent Var-Cov matrix using QR decomposition of X, and residuals#
	##
	#  (X'X)-1 Omegahat (X'X)-1#
	# if L=0, Phi0 = X' diag(e_i^2/(1-hii)^2) X  -- hii is i,i, element of hat matrix use "H3" method from sandwich#
	# if Lne0, Omegahat = omega_0*Phi_0 + 2sum(l=1 to L) omega_l*Phi_l ; omega_l = 1 - (l/L+1)#
	#        phi_l=sum(t=l+1 to T) x_t e_t e_t-l (x_t-l)'  x_t is the "t"th row of X and e_t is the lsq residual#
	# or#
	#        phi_l= (XP*ep)'(XM*em)#
	#        XP=X[l:T,] ep[l:T] ; XM=X[1:(T-l),]  em[1:T-l]#
	##
	#  in terms of X=QR  this is R-1(R-1)' OmegaH R-1(R-1)'#
	# note the hat matrix is QQ'#
	##
	##
	k=ncol(qrX$qr)#
	R=qr.R(qrX)#
	Q=qr.Q(qrX)#
	X=Q%*%R#
	n=nrow(X)#
	RI=backsolve(R,diag(k))#
	lambda=res**2#
	lambda=lambda/((1-rowSums(Q*Q))**2)    # here we are fetching diag elements of QQ'#
	if(L==0)#
	{#
	  QRIt=Q%*%t(RI)#
	  V=crossprod(QRIt,QRIt*lambda)       # for L=0, V=(X'X)-1X' Lambda X (X'X)-1 = t(QRI) Lambda QRI#
	}#
	else#
	{#
		phi0=crossprod(X,X*lambda)#
		Omegahat=phi0#
		for(l in 1:L )#
		{#
			omega_l=1-l/(L+1)	 		# N-W weights#
			Omegahat=Omegahat+2*omega_l*crossprod((X[l:n,]*res[l:n]),(X[1:(n-l),]*res[1:(n-l)]))#
		}#
	   XpXI=crossprod(t(RI))#
	   V=crossprod(XpXI,Omegahat%*%XpXI)#
	}#
	std_err=sqrt(diag(V))#
	return(list(V=V,std_err=std_err))#
}
HACVar(lmfit$qr,lmfit$res,L=1)
HACVar=function(qrX,res,L){#
	# 2/11 P. Rossi#
	#  function  to compute heteroskedastic autocorrelation#
	#   consistent Var-Cov matrix using QR decomposition of X, and residuals#
	##
	#  (X'X)-1 Omegahat (X'X)-1#
	# if L=0, Phi0 = X' diag(e_i^2/(1-hii)^2) X  -- hii is i,i, element of hat matrix use "H3" method from sandwich#
	# if Lne0, Omegahat = omega_0*Phi_0 + 2sum(l=1 to L) omega_l*Phi_l ; omega_l = 1 - (l/L+1)#
	#        phi_l=sum(t=l+1 to T) x_t e_t e_t-l (x_t-l)'  x_t is the "t"th row of X and e_t is the lsq residual#
	# or#
	#        phi_l= (XP*ep)'(XM*em)#
	#        XP=X[(l+1):T,] ep[(l+1):T] ; XM=X[1:(T-l),]  em[1:T-l]#
	##
	#  in terms of X=QR  this is R-1(R-1)' OmegaH R-1(R-1)'#
	# note the hat matrix is QQ'#
	##
	##
	k=ncol(qrX$qr)#
	R=qr.R(qrX)#
	Q=qr.Q(qrX)#
	X=Q%*%R#
	n=nrow(X)#
	RI=backsolve(R,diag(k))#
	lambda=res**2#
	lambda=lambda/((1-rowSums(Q*Q))**2)    # here we are fetching diag elements of QQ'#
	if(L==0)#
	{#
	  QRIt=Q%*%t(RI)#
	  V=crossprod(QRIt,QRIt*lambda)       # for L=0, V=(X'X)-1X' Lambda X (X'X)-1 = t(QRI) Lambda QRI#
	}#
	else#
	{#
		phi0=crossprod(X,X*lambda)#
		Omegahat=phi0#
		for(l in 1:L )#
		{#
			omega_l=1-l/(L+1)	 		# N-W weights#
			Omegahat=Omegahat+2*omega_l*crossprod((X[(l+1):n,]*res[(l+1):n]),(X[1:(n-l),]*res[1:(n-l)]))#
		}#
	   XpXI=crossprod(t(RI))#
	   V=crossprod(XpXI,Omegahat%*%XpXI)#
	}#
	std_err=sqrt(diag(V))#
	return(list(V=V,std_err=std_err))#
}
HACVar(lmfit$qr,lmfit$res,L=1)
HACVar(lmfit$qr,lmfit$res,L=0)
vcovHAC(lmfit,weights=NeweyWest(lmfit,lag=1),adjust=FALSE)
NeweyWest(lmfit,lag=1)
?NeweyWest
NeweyWest(lmfit,lag=1,prewhite=FALSE)
HACVar=function(qrX,res,L){#
	# 2/11 P. Rossi#
	#  function  to compute heteroskedastic autocorrelation#
	#   consistent Var-Cov matrix using QR decomposition of X, and residuals#
	##
	#  (X'X)-1 Omegahat (X'X)-1#
	# if L=0, Phi0 = X' diag(e_i^2/(1-hii)^2) X  -- hii is i,i, element of hat matrix use "H3" method from sandwich#
	# if Lne0, Omegahat = omega_0*Phi_0 + 2sum(l=1 to L) omega_l*Phi_l ; omega_l = 1 - (l/L+1)#
	#        phi_l=sum(t=l+1 to T) x_t e_t e_t-l (x_t-l)'  x_t is the "t"th row of X and e_t is the lsq residual#
	# or#
	#        phi_l= (XP*ep)'(XM*em)#
	#        XP=X[(l+1):T,] ep[(l+1):T] ; XM=X[1:(T-l),]  em[1:T-l]#
	##
	#  in terms of X=QR  this is R-1(R-1)' OmegaH R-1(R-1)'#
	# note the hat matrix is QQ'#
	##
	##
	k=ncol(qrX$qr)#
	R=qr.R(qrX)#
	Q=qr.Q(qrX)#
	X=Q%*%R#
	n=nrow(X)#
	RI=backsolve(R,diag(k))#
	lambda=res**2#
#	lambda=lambda/((1-rowSums(Q*Q))**2)    # here we are fetching diag elements of QQ'#
	if(L==0)#
	{#
	  QRIt=Q%*%t(RI)#
	  V=crossprod(QRIt,QRIt*lambda)       # for L=0, V=(X'X)-1X' Lambda X (X'X)-1 = t(QRI) Lambda QRI#
	}#
	else#
	{#
		phi0=crossprod(X,X*lambda)#
		Omegahat=phi0#
		for(l in 1:L )#
		{#
			omega_l=1-l/(L+1)	 		# N-W weights#
			Omegahat=Omegahat+2*omega_l*crossprod((X[(l+1):n,]*res[(l+1):n]),(X[1:(n-l),]*res[1:(n-l)]))#
		}#
	   XpXI=crossprod(t(RI))#
	   V=crossprod(XpXI,Omegahat%*%XpXI)#
	}#
	std_err=sqrt(diag(V))#
	return(list(V=V,std_err=std_err))#
}
NeweyWest(lmfit,lag=1,prewhite=FALSE)
HACVar(lmfit$qr,lmfit$res,L=1)
5*(.02362072+.0290180)
HACVar=function(qrX,res,L){#
	# 2/11 P. Rossi#
	#  function  to compute heteroskedastic autocorrelation#
	#   consistent Var-Cov matrix using QR decomposition of X, and residuals#
	##
	#  (X'X)-1 Omegahat (X'X)-1#
	# if L=0, Phi0 = X' diag(e_i^2/(1-hii)^2) X  -- hii is i,i, element of hat matrix use "H3" method from sandwich#
	# if Lne0, Omegahat = omega_0*Phi_0 + sum(l=1 to L) omega_l*Phi_l ; omega_l = 1 - (l/L+1)#
	#        phi_l=sum(t=l+1 to T) x_t e_t e_t-l (x_t-l)'  x_t is the "t"th row of X and e_t is the lsq residual#
	# or#
	#        phi_l= (XP*ep)'(XM*em)+ t(   )#
	#        XP=X[(l+1):T,] ep[(l+1):T] ; XM=X[1:(T-l),]  em[1:T-l]#
	##
	#  in terms of X=QR  this is R-1(R-1)' OmegaH R-1(R-1)'#
	# note the hat matrix is QQ'#
	##
	##
	k=ncol(qrX$qr)#
	R=qr.R(qrX)#
	Q=qr.Q(qrX)#
	X=Q%*%R#
	n=nrow(X)#
	RI=backsolve(R,diag(k))#
	lambda=res**2#
#	lambda=lambda/((1-rowSums(Q*Q))**2)    # here we are fetching diag elements of QQ'#
	if(L==0)#
	{#
	  QRIt=Q%*%t(RI)#
	  V=crossprod(QRIt,QRIt*lambda)       # for L=0, V=(X'X)-1X' Lambda X (X'X)-1 = t(QRI) Lambda QRI#
	}#
	else#
	{#
		phi0=crossprod(X,X*lambda)#
		Omegahat=phi0#
		for(l in 1:L )#
		{#
			omega_l=1-l/(L+1)	 		# N-W weights#
			mat=crossprod((X[(l+1):n,]*res[(l+1):n]),(X[1:(n-l),]*res[1:(n-l)])#
			mat=mat+t(mat)#
			Omegahat=Omegahat+omega_l*mat#
			   #
		}#
	   XpXI=crossprod(t(RI))#
	   V=crossprod(XpXI,Omegahat%*%XpXI)#
	}#
	std_err=sqrt(diag(V))#
	return(list(V=V,std_err=std_err))#
}
HACVar=function(qrX,res,L){#
	# 2/11 P. Rossi#
	#  function  to compute heteroskedastic autocorrelation#
	#   consistent Var-Cov matrix using QR decomposition of X, and residuals#
	##
	#  (X'X)-1 Omegahat (X'X)-1#
	# if L=0, Phi0 = X' diag(e_i^2/(1-hii)^2) X  -- hii is i,i, element of hat matrix use "H3" method from sandwich#
	# if Lne0, Omegahat = omega_0*Phi_0 + sum(l=1 to L) omega_l*Phi_l ; omega_l = 1 - (l/L+1)#
	#        phi_l=sum(t=l+1 to T) x_t e_t e_t-l (x_t-l)'  x_t is the "t"th row of X and e_t is the lsq residual#
	# or#
	#        phi_l= (XP*ep)'(XM*em)+ t(   )#
	#        XP=X[(l+1):T,] ep[(l+1):T] ; XM=X[1:(T-l),]  em[1:T-l]#
	##
	#  in terms of X=QR  this is R-1(R-1)' OmegaH R-1(R-1)'#
	# note the hat matrix is QQ'#
	##
	##
	k=ncol(qrX$qr)#
	R=qr.R(qrX)#
	Q=qr.Q(qrX)#
	X=Q%*%R#
	n=nrow(X)#
	RI=backsolve(R,diag(k))#
	lambda=res**2#
#	lambda=lambda/((1-rowSums(Q*Q))**2)    # here we are fetching diag elements of QQ'#
	if(L==0)#
	{#
	  QRIt=Q%*%t(RI)#
	  V=crossprod(QRIt,QRIt*lambda)       # for L=0, V=(X'X)-1X' Lambda X (X'X)-1 = t(QRI) Lambda QRI#
	}#
	else#
	{#
		phi0=crossprod(X,X*lambda)#
		Omegahat=phi0#
		for(l in 1:L )#
		{#
			omega_l=1-l/(L+1)	 		# N-W weights#
			mat=crossprod((X[(l+1):n,]*res[(l+1):n]),(X[1:(n-l),]*res[1:(n-l)]))#
			mat=mat+t(mat)#
			Omegahat=Omegahat+omega_l*mat#
			   #
		}#
	   XpXI=crossprod(t(RI))#
	   V=crossprod(XpXI,Omegahat%*%XpXI)#
	}#
	std_err=sqrt(diag(V))#
	return(list(V=V,std_err=std_err))#
}
HACVar(lmfit$qr,lmfit$res,L=1)
NeweyWest(lmfit,lag=1,prewhite=FALSE)
HACVar(lmfit$qr,lmfit$res,L=2)
NeweyWest(lmfit,lag=2,prewhite=FALSE)
NeweyWest
vcovHAC
lmSumm=function(lmfit,L=0,HAC=FALSE){#
##
#  function to "clean" lm summary and include heteroskedastic/autocorrelation consistent std errors#
##
HACVar=function(qrX,res,L){#
	# 2/11 P. Rossi#
	#  function  to compute heteroskedastic autocorrelation#
	#   consistent Var-Cov matrix using QR decomposition of X, and residuals#
	##
	#  (X'X)-1 Omegahat (X'X)-1#
	# if L=0, Phi0 = X' diag(e_i^2/(1-hii)^2) X  -- hii is i,i, element of hat matrix use "H3" method from sandwich#
	# if Lne0, Omegahat = omega_0*Phi_0 + sum(l=1 to L) omega_l*Phi_l ; omega_l = 1 - (l/L+1)#
	#        phi_l=sum(t=l+1 to T) x_t e_t e_t-l (x_t-l)'  x_t is the "t"th row of X and e_t is the lsq residual#
	# or#
	#        phi_l= (XP*ep)'(XM*em)+ t(   )#
	#        XP=X[(l+1):T,] ep[(l+1):T] ; XM=X[1:(T-l),]  em[1:T-l]#
	##
	#  in terms of X=QR  this is R-1(R-1)' OmegaH R-1(R-1)'#
	# note the hat matrix is QQ'#
	##
	##
	k=ncol(qrX$qr)#
	R=qr.R(qrX)#
	Q=qr.Q(qrX)#
	X=Q%*%R#
	n=nrow(X)#
	RI=backsolve(R,diag(k))#
	lambda=res**2#
	lambda=lambda/((1-rowSums(Q*Q))**2)    # here we are fetching diag elements of QQ'#
	if(L==0)#
	{#
	  QRIt=Q%*%t(RI)#
	  V=crossprod(QRIt,QRIt*lambda)       # for L=0, V=(X'X)-1X' Lambda X (X'X)-1 = t(QRI) Lambda QRI#
	}#
	else#
	{#
		phi0=crossprod(X,X*res**2)#
		Omegahat=phi0#
		for(l in 1:L )#
		{#
			omega_l=1-l/(L+1)	 		# N-W weights#
			mat=crossprod((X[(l+1):n,]*res[(l+1):n]),(X[1:(n-l),]*res[1:(n-l)]))#
			mat=mat+t(mat)#
			Omegahat=Omegahat+omega_l*mat#
			   #
		}#
	   XpXI=crossprod(t(RI))#
	   V=crossprod(XpXI,Omegahat%*%XpXI)#
	}#
	std_err=sqrt(diag(V))#
	return(list(V=V,std_err=std_err))#
}#
pval=function(x){1-pf(x[1],df1=x[2],df2=x[3])}#
#
pandterm = function(message) {#
        stop(message, call. = FALSE) }#
if (missing(lmfit)) pandterm("Requires output from the lm command as in lmSummary(lm(y~x))")#
if (attributes(lmfit)$class != "lm") pandterm("input not from lm command")#
cat("Multiple Regression Analysis:",fill=TRUE)#
n=length(lmfit$res)#
k=length(lmfit$coef)#
cat("    ",k," regressors(including intercept) and ",n," observations",sep="",fill=TRUE)#
if(HAC==TRUE)#
{#
	cat("    with heteroskedastic|autocorrelation consistent standard errors",fill=TRUE)#
	cat("    Lag truncation =",L,fill=TRUE)#
}#
cat("",fill=TRUE)#
print(lmfit$call,fill=TRUE)#
cat("",fill=TRUE)#
##
# compute std errors#
##
slm=summary(lmfit)#
s=slm$sigma#
rsq=slm$r.squared#
adjrsq=slm$adj.r.squared#
fstat=slm$fstat  # note this is a vector of three nums fstat, df1, df2#
if(HAC)#
{#
	if(n<(L+30)) pandterm("make sure N(T) > L+30")#
	std_err=HACVar(lmfit$qr,lmfit$res,L=L)$std_err#
	}#
else#
{#
	s=sqrt(sum(res**2)/(length(lmfit$res)-k))#
	RI=backsolve(qr.R(lmfit$qr),diag(k))#
	V=s**2*crossprod(t(RI))#
	std_err=sqrt(diag(V))#
}#
t=lmfit$coef/std_err#
t_pval=2*(1-pt(abs(t),df=(n-k)))#
output=matrix(double(k*4),ncol=4)#
rownames(output)=names(lmfit$coef)#
coef=lmfit$coef#
names(coef)=NULL#
colnames(output)=c("Estimate","Std Error","t value","p value")#
output[,1]=signif(coef,4)#
output[,2]=signif(std_err,4)#
output[,3]=round(t,2)#
output[,4]=round(t_pval,3)#
cat("Coefficients:",fill=TRUE)#
print(output)#
cat("---",fill=TRUE)#
cat("Standard Error of the Regression: ",signif(s,4),fill=TRUE)#
cat("Multiple R-squared: ",round(rsq,3)," Adjusted R-squared: ",round(adjrsq,3),fill=TRUE)#
if(!HAC) #
   {cat("Overall F stat: ",round(fstat[1],2)," on ",fstat[2]," and ",fstat[3]," DF,"," pvalue= ",round(pval(fstat),3),#
         sep="",fill=TRUE)}#
}
lmSumm(lmfit,HAC=TRUE)
mSumm=function(lmfit,L=0,HAC=FALSE){#
##
#  function to "clean" lm summary and include heteroskedastic/autocorrelation consistent std errors#
##
HACVar=function(qrX,res,L){#
	# 2/11 P. Rossi#
	#  function  to compute heteroskedastic autocorrelation#
	#   consistent Var-Cov matrix using QR decomposition of X, and residuals#
	##
	#  (X'X)-1 Omegahat (X'X)-1#
	# if L=0, Phi0 = X' diag(e_i^2/(1-hii)^2) X  -- hii is i,i, element of hat matrix use "H3" method from sandwich#
	# if Lne0, Omegahat = omega_0*Phi_0 + sum(l=1 to L) omega_l*Phi_l ; omega_l = 1 - (l/L+1)#
	#        phi_l=sum(t=l+1 to T) x_t e_t e_t-l (x_t-l)'  x_t is the "t"th row of X and e_t is the lsq residual#
	# or#
	#        phi_l= (XP*ep)'(XM*em)+ t(   )#
	#        XP=X[(l+1):T,] ep[(l+1):T] ; XM=X[1:(T-l),]  em[1:T-l]#
	##
	#  in terms of X=QR  this is R-1(R-1)' OmegaH R-1(R-1)'#
	# note the hat matrix is QQ'#
	##
	##
	k=ncol(qrX$qr)#
	R=qr.R(qrX)#
	Q=qr.Q(qrX)#
	X=Q%*%R#
	n=nrow(X)#
	RI=backsolve(R,diag(k))#
	lambda=res**2#
	lambda=lambda/((1-rowSums(Q*Q))**2)    # here we are fetching diag elements of QQ'#
	if(L==0)#
	{#
	  QRIt=Q%*%t(RI)#
	  V=crossprod(QRIt,QRIt*lambda)       # for L=0, V=(X'X)-1X' Lambda X (X'X)-1 = t(QRI) Lambda QRI#
	}#
	else#
	{#
		phi0=crossprod(X,X*res**2)#
		Omegahat=phi0#
		for(l in 1:L )#
		{#
			omega_l=1-l/(L+1)	 		# N-W weights#
			mat=crossprod((X[(l+1):n,]*res[(l+1):n]),(X[1:(n-l),]*res[1:(n-l)]))#
			mat=mat+t(mat)#
			Omegahat=Omegahat+omega_l*mat#
			   #
		}#
	   XpXI=crossprod(t(RI))#
	   V=crossprod(XpXI,Omegahat%*%XpXI)#
	}#
	std_err=sqrt(diag(V))#
	return(list(V=V,std_err=std_err))#
}#
pval=function(x){1-pf(x[1],df1=x[2],df2=x[3])}#
#
pandterm = function(message) {#
        stop(message, call. = FALSE) }#
if (missing(lmfit)) pandterm("Requires output from the lm command as in lmSummary(lm(y~x))")#
if (attributes(lmfit)$class != "lm") pandterm("input not from lm command")#
cat("Multiple Regression Analysis:",fill=TRUE)#
n=length(lmfit$res)#
k=length(lmfit$coef)#
cat("    ",k," regressors(including intercept) and ",n," observations",sep="",fill=TRUE)#
if(HAC==TRUE)#
{#
	cat("    with heteroskedastic|autocorrelation consistent standard errors",fill=TRUE)#
	cat("    Lag truncation =",L,fill=TRUE)#
}#
cat("",fill=TRUE)#
print(lmfit$call,fill=TRUE)#
cat("",fill=TRUE)#
##
# compute std errors#
##
slm=summary(lmfit)#
s=slm$sigma#
rsq=slm$r.squared#
adjrsq=slm$adj.r.squared#
fstat=slm$fstat  # note this is a vector of three nums fstat, df1, df2#
if(HAC)#
{#
	if(n<(L+1)) pandterm("make sure N > L+1")#
	std_err=HACVar(lmfit$qr,lmfit$res,L=L)$std_err#
	}#
else#
{#
	s=sqrt(sum(res**2)/(length(lmfit$res)-k))#
	RI=backsolve(qr.R(lmfit$qr),diag(k))#
	V=s**2*crossprod(t(RI))#
	std_err=sqrt(diag(V))#
}#
t=lmfit$coef/std_err#
t_pval=2*(1-pt(abs(t),df=(n-k)))#
output=matrix(double(k*4),ncol=4)#
rownames(output)=names(lmfit$coef)#
coef=lmfit$coef#
names(coef)=NULL#
colnames(output)=c("Estimate","Std Error","t value","p value")#
output[,1]=signif(coef,4)#
output[,2]=signif(std_err,4)#
output[,3]=round(t,2)#
output[,4]=round(t_pval,3)#
cat("Coefficients:",fill=TRUE)#
print(output)#
cat("---",fill=TRUE)#
cat("Standard Error of the Regression: ",signif(s,4),fill=TRUE)#
cat("Multiple R-squared: ",round(rsq,3)," Adjusted R-squared: ",round(adjrsq,3),fill=TRUE)#
if(!HAC) #
   {cat("Overall F stat: ",round(fstat[1],2)," on ",fstat[2]," and ",fstat[3]," DF,"," pvalue= ",round(pval(fstat),3),#
         sep="",fill=TRUE)}#
if(HAC & (n-k) < (50+20*L))#
   {cat("Warning: Sample Size of",n,"too small for accurate use of HAC"),fill=TRUE}#
}
lmSumm=function(lmfit,L=0,HAC=FALSE){#
##
#  function to "clean" lm summary and include heteroskedastic/autocorrelation consistent std errors#
##
HACVar=function(qrX,res,L){#
	# 2/11 P. Rossi#
	#  function  to compute heteroskedastic autocorrelation#
	#   consistent Var-Cov matrix using QR decomposition of X, and residuals#
	##
	#  (X'X)-1 Omegahat (X'X)-1#
	# if L=0, Phi0 = X' diag(e_i^2/(1-hii)^2) X  -- hii is i,i, element of hat matrix use "H3" method from sandwich#
	# if Lne0, Omegahat = omega_0*Phi_0 + sum(l=1 to L) omega_l*Phi_l ; omega_l = 1 - (l/L+1)#
	#        phi_l=sum(t=l+1 to T) x_t e_t e_t-l (x_t-l)'  x_t is the "t"th row of X and e_t is the lsq residual#
	# or#
	#        phi_l= (XP*ep)'(XM*em)+ t(   )#
	#        XP=X[(l+1):T,] ep[(l+1):T] ; XM=X[1:(T-l),]  em[1:T-l]#
	##
	#  in terms of X=QR  this is R-1(R-1)' OmegaH R-1(R-1)'#
	# note the hat matrix is QQ'#
	##
	##
	k=ncol(qrX$qr)#
	R=qr.R(qrX)#
	Q=qr.Q(qrX)#
	X=Q%*%R#
	n=nrow(X)#
	RI=backsolve(R,diag(k))#
	lambda=res**2#
	lambda=lambda/((1-rowSums(Q*Q))**2)    # here we are fetching diag elements of QQ'#
	if(L==0)#
	{#
	  QRIt=Q%*%t(RI)#
	  V=crossprod(QRIt,QRIt*lambda)       # for L=0, V=(X'X)-1X' Lambda X (X'X)-1 = t(QRI) Lambda QRI#
	}#
	else#
	{#
		phi0=crossprod(X,X*res**2)#
		Omegahat=phi0#
		for(l in 1:L )#
		{#
			omega_l=1-l/(L+1)	 		# N-W weights#
			mat=crossprod((X[(l+1):n,]*res[(l+1):n]),(X[1:(n-l),]*res[1:(n-l)]))#
			mat=mat+t(mat)#
			Omegahat=Omegahat+omega_l*mat#
			   #
		}#
	   XpXI=crossprod(t(RI))#
	   V=crossprod(XpXI,Omegahat%*%XpXI)#
	}#
	std_err=sqrt(diag(V))#
	return(list(V=V,std_err=std_err))#
}#
pval=function(x){1-pf(x[1],df1=x[2],df2=x[3])}#
#
pandterm = function(message) {#
        stop(message, call. = FALSE) }#
if (missing(lmfit)) pandterm("Requires output from the lm command as in lmSummary(lm(y~x))")#
if (attributes(lmfit)$class != "lm") pandterm("input not from lm command")#
cat("Multiple Regression Analysis:",fill=TRUE)#
n=length(lmfit$res)#
k=length(lmfit$coef)#
cat("    ",k," regressors(including intercept) and ",n," observations",sep="",fill=TRUE)#
if(HAC==TRUE)#
{#
	cat("    with heteroskedastic|autocorrelation consistent standard errors",fill=TRUE)#
	cat("    Lag truncation =",L,fill=TRUE)#
}#
cat("",fill=TRUE)#
print(lmfit$call,fill=TRUE)#
cat("",fill=TRUE)#
##
# compute std errors#
##
slm=summary(lmfit)#
s=slm$sigma#
rsq=slm$r.squared#
adjrsq=slm$adj.r.squared#
fstat=slm$fstat  # note this is a vector of three nums fstat, df1, df2#
if(HAC)#
{#
	if(n<(L+1)) pandterm("make sure N > L+1")#
	std_err=HACVar(lmfit$qr,lmfit$res,L=L)$std_err#
	}#
else#
{#
	s=sqrt(sum(res**2)/(length(lmfit$res)-k))#
	RI=backsolve(qr.R(lmfit$qr),diag(k))#
	V=s**2*crossprod(t(RI))#
	std_err=sqrt(diag(V))#
}#
t=lmfit$coef/std_err#
t_pval=2*(1-pt(abs(t),df=(n-k)))#
output=matrix(double(k*4),ncol=4)#
rownames(output)=names(lmfit$coef)#
coef=lmfit$coef#
names(coef)=NULL#
colnames(output)=c("Estimate","Std Error","t value","p value")#
output[,1]=signif(coef,4)#
output[,2]=signif(std_err,4)#
output[,3]=round(t,2)#
output[,4]=round(t_pval,3)#
cat("Coefficients:",fill=TRUE)#
print(output)#
cat("---",fill=TRUE)#
cat("Standard Error of the Regression: ",signif(s,4),fill=TRUE)#
cat("Multiple R-squared: ",round(rsq,3)," Adjusted R-squared: ",round(adjrsq,3),fill=TRUE)#
if(!HAC) #
   {cat("Overall F stat: ",round(fstat[1],2)," on ",fstat[2]," and ",fstat[3]," DF,"," pvalue= ",round(pval(fstat),3),#
         sep="",fill=TRUE)}#
if(HAC & (n-k) < (50+20*L))#
   {cat("Warning: Sample Size of",n,"too small for accurate use of HAC",fill=TRUE)}#
}
lmSumm(lmfit,HAC=TRUE)
lmSumm(lmfit)
lmSumm=function(lmfit,L=0,HAC=FALSE){#
##
#  function to "clean" lm summary and include heteroskedastic/autocorrelation consistent std errors#
##
HACVar=function(qrX,res,L){#
	# 2/11 P. Rossi#
	#  function  to compute heteroskedastic autocorrelation#
	#   consistent Var-Cov matrix using QR decomposition of X, and residuals#
	##
	#  (X'X)-1 Omegahat (X'X)-1#
	# if L=0, Phi0 = X' diag(e_i^2/(1-hii)^2) X  -- hii is i,i, element of hat matrix use "H3" method from sandwich#
	# if Lne0, Omegahat = omega_0*Phi_0 + sum(l=1 to L) omega_l*Phi_l ; omega_l = 1 - (l/L+1)#
	#        phi_l=sum(t=l+1 to T) x_t e_t e_t-l (x_t-l)'  x_t is the "t"th row of X and e_t is the lsq residual#
	# or#
	#        phi_l= (XP*ep)'(XM*em)+ t(   )#
	#        XP=X[(l+1):T,] ep[(l+1):T] ; XM=X[1:(T-l),]  em[1:T-l]#
	##
	#  in terms of X=QR  this is R-1(R-1)' OmegaH R-1(R-1)'#
	# note the hat matrix is QQ'#
	##
	##
	k=ncol(qrX$qr)#
	R=qr.R(qrX)#
	Q=qr.Q(qrX)#
	X=Q%*%R#
	n=nrow(X)#
	RI=backsolve(R,diag(k))#
	lambda=res**2#
	lambda=lambda/((1-rowSums(Q*Q))**2)    # here we are fetching diag elements of QQ'#
	if(L==0)#
	{#
	  QRIt=Q%*%t(RI)#
	  V=crossprod(QRIt,QRIt*lambda)       # for L=0, V=(X'X)-1X' Lambda X (X'X)-1 = t(QRI) Lambda QRI#
	}#
	else#
	{#
		phi0=crossprod(X,X*res**2)#
		Omegahat=phi0#
		for(l in 1:L )#
		{#
			omega_l=1-l/(L+1)	 		# N-W weights#
			mat=crossprod((X[(l+1):n,]*res[(l+1):n]),(X[1:(n-l),]*res[1:(n-l)]))#
			mat=mat+t(mat)#
			Omegahat=Omegahat+omega_l*mat#
			   #
		}#
	   XpXI=crossprod(t(RI))#
	   V=crossprod(XpXI,Omegahat%*%XpXI)#
	}#
	std_err=sqrt(diag(V))#
	return(list(V=V,std_err=std_err))#
}#
pval=function(x){1-pf(x[1],df1=x[2],df2=x[3])}#
#
pandterm = function(message) {#
        stop(message, call. = FALSE) }#
if (missing(lmfit)) pandterm("Requires output from the lm command as in lmSummary(lm(y~x))")#
if (attributes(lmfit)$class != "lm") pandterm("input not from lm command")#
cat("Multiple Regression Analysis:",fill=TRUE)#
n=length(lmfit$res)#
k=length(lmfit$coef)#
cat("    ",k," regressors(including intercept) and ",n," observations",sep="",fill=TRUE)#
if(HAC==TRUE)#
{#
	cat("    with heteroskedastic|autocorrelation consistent standard errors",fill=TRUE)#
	cat("    Lag truncation =",L,fill=TRUE)#
}#
cat("",fill=TRUE)#
print(lmfit$call,fill=TRUE)#
cat("",fill=TRUE)#
##
# compute std errors#
##
slm=summary(lmfit)#
s=slm$sigma#
rsq=slm$r.squared#
adjrsq=slm$adj.r.squared#
fstat=slm$fstat  # note this is a vector of three nums fstat, df1, df2#
if(HAC)#
{#
	if(n<(L+1)) pandterm("make sure N > L+1")#
	std_err=HACVar(lmfit$qr,lmfit$res,L=L)$std_err#
	}#
else#
{#
	s=sqrt(sum(lmfit$res**2)/(length(lmfit$res)-k))#
	RI=backsolve(qr.R(lmfit$qr),diag(k))#
	V=s**2*crossprod(t(RI))#
	std_err=sqrt(diag(V))#
}#
t=lmfit$coef/std_err#
t_pval=2*(1-pt(abs(t),df=(n-k)))#
output=matrix(double(k*4),ncol=4)#
rownames(output)=names(lmfit$coef)#
coef=lmfit$coef#
names(coef)=NULL#
colnames(output)=c("Estimate","Std Error","t value","p value")#
output[,1]=signif(coef,4)#
output[,2]=signif(std_err,4)#
output[,3]=round(t,2)#
output[,4]=round(t_pval,3)#
cat("Coefficients:",fill=TRUE)#
print(output)#
cat("---",fill=TRUE)#
cat("Standard Error of the Regression: ",signif(s,4),fill=TRUE)#
cat("Multiple R-squared: ",round(rsq,3)," Adjusted R-squared: ",round(adjrsq,3),fill=TRUE)#
if(!HAC) #
   {cat("Overall F stat: ",round(fstat[1],2)," on ",fstat[2]," and ",fstat[3]," DF,"," pvalue= ",round(pval(fstat),3),#
         sep="",fill=TRUE)}#
if(HAC & (n-k) < (50+20*L))#
   {cat("Warning: Sample Size of",n,"too small for accurate use of HAC",fill=TRUE)}#
}
lmSumm(lmfit)
lmSumm(lmfit,HAC=TRUE)
search()
lmSumm(lm(SALINF~ADVINF))
lmSumm(lm(SALINF~ADVINF),L=10,HAC=TRUE)
NeweyWest(lm(SALINF~ADVINF),lag=10,prewhite=FALSE)
sqrt(.63685)
??Rd
prompt(lmSumm)
lmSumm
data(cheese)
?save
save(file="cheese.rda")
load("/Users/perossichi/workspace/cheese.rda")
data(detergent)
data(cheese)
ls()
save(cheese,file="cheese.rda")
save(detergent,file="detergent.rda")
?resave
??resave
q()
